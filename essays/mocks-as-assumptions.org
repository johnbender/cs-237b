#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="style.css" />
#+OPTIONS: ^:nil
* mocks as proof assumptions
  "Rational discussion is useful only when there is a significant base of shared assumptions." - Noam Chomsky

  Mocks are like proof assumptions for very weak proofs (test). They assume much and prove little.
  But! Because so much is assumed we can learn about the expected system context from those assumptions.
  To wit, knowing about mocks means knowing the assumptions of a test.
  Knowing the assumptions of a test means knowing about expected system context.
  If we can gather the assumptions of tests encoded by mocks we can understand context.

  - Input: A set of tests and mocks/stubs for those tests written during the natural course of testing.
  - Output: A human readable set of assumptions derived from the mocks for those tests.

** mocks/tests: weak in isolation, strong in aggregate
   - they embed the programmers understanding the system
   - they provide some guarantees about behavior, however narrow
   - but how do we harness that information?
   - programmers reading tests have a narrow focus

** mocks as assumptions, tests as proofs
   - when we test using mocks we state our assumptions about context in terms of those mocks
   - tests prove a very particular property under a very particular set of assumptions defined by the mocks

** assumptions can tell us interesting things about a system
   - where should it be executing (posix, etc)
   - what data does it want from external resources (content)
   - how should that data be delivered (format, async/sync, etc)
   - what data should always/sometimes/never exist

* example
  Consider the following test from the perspective of someone who doesn't know Ruby particularly well or Rails.

  #+begin_src ruby
  # positive test
  def test_full_name
    user = User.find(1)
    assert_equal(user.full_name, "Jim Jones")
  end
  #+end_src

  Confusion can arise from the ambiguous nature of `full_name`. It can be a property or an attribute. But because the test writer may have mocked/stubbed classes/methods other than `full_name` we can inspect them to provide context to the test reader.

  #+begin_src ruby
  def User.find(id)
    if id == 1
      User.new( first_name: "Jim", last_name: "Jones" )
    else
      User.new( first_name: "Jack", last_name: "Jomp" )
    end
  end
  #+end_src

  The stubbed method `find` tells us many things about the test writer's assumptions. Most obviously `full_name` must do some string concatenation to produce the expected result so we can safely assume it behaves as a method.

  In fact there are many assumptions that we can derive from the stubbed `find` method and they can tell us interesting things about the expected context for the test.

** assumptions
   - ...
   - database exists/accessible
   - user relation exists
   - user relation has at least one tuple
   - user relation has first_name
   - user relation has last_name
   - user relation's first row has first_name=Jim and last_name=Jones

  |----+------------+-----------+-----|
  | id | first_name | last_name | ... |
  |----+------------+-----------+-----|
  | 1  | Jim        | Jones     |     |
  | ?? | ??         | ??        |     |
  |----+------------+-----------+-----|

  With these assumptions in mind we can also speak to what is and is not provable:

   provable: first row such that the full_name method gets you "Jim Jones"

   not provable: exists a row such that full_name != "Jim Jones"

* example
  Next consider the negative test along side the original positive test:

  #+begin_src ruby
  # negative
  def test_full_name_not
    user = User.find(2)
    assert_not_equal(user.full_name, "Jim Jones")
  end
  #+end_src

  This also comes with a set of assumption associated with the mocked and stubbed object. The common set of assumptions provides useful context for the test.

** assumptions
   - ...
   - database exists/accessible
   - user relation exists
   - user relation has at least one tuple
   - user relation has first_name
   - user relation has last_name
   - user relation's second row does not have first_name=Jim and last_name=Jones

  |----+------------+-----------+-----|
  | id | first_name | last_name | ... |
  |----+------------+-----------+-----|
  |  1 | ??         | ??        |     |
  |  2 | ??         | ??        |     |
  |----+------------+-----------+-----|

   provable: second row such that the full_name method does not get you "Jim Jones"

   not provable: exists a row such that full_name = anything at all

* working with assumptions
  Now that we know some of the assumptions how can we use them to learn about the system?

** intersection of assumptions
  - ...
  - database exists/accessible
  - user relation exists
  - user relation has at least one tuple
  - user relation has first_name
  - user relation has last_name

  taking the intersection of shared assumptions provides a consistent context
  and elides test specific extra context (second row, first row, etc).
  one could recover most of the schema from these assumptions.

  (side note) a good system for helping people learn about code
  should make it easy to rebuild that system (e.g. recover schema)

** union of assumptions
   given all the assumptions made for all the tests,
   (if they are consistent)
   what can we prove now?

   provable:
   - exists a row such that full_name != "Jim Jones"
   - exists a row such that full_name = anything at all

* proof theoretic view
  We can track the use of each assumption as in proofs.
  The intersection of all the elided assumptions are the ones we don't care about.

  which argument is better:
  - it's raining, if it's raining the sidewalk is wet, I know that the sidewalk is wet
  - it's raining, if it's raining the sidewalk is wet, oranges taste great, I know that the sidewalk is wet

  Clearly the second is a weaker argument.
  Minimizing assumptions brings clarity to the proof.
  In the same way minimizing assumptions brings clarity to tests and the system.

  #+begin_src
  T |- psi
  -------------- (thinning)
  T, phi |- psi
  #+end_src

  Often programmers use setup methods as a dumping ground for mocking test setup which confuses context.
  Rails sets up a lot of stuff for tests automatically but those things are well defined,
  `setup` methods also define assumptions. We can search through the space of assumption sets to
  find minimal set where tests pass (i.e. proofs go through).

* questions
  - which proofs get grouped? module/class/etc
  - everything is an assumption up to a point, how can we limit the search space of requirements?
  - how many assumptions should we include in the set? shouldn't get all the way down to one's and zeros
  - how do you turn mocked code into readable assumptions? from example, can be derived from test database queries
  - hard to make general, depends on mocking framework?
