* "Rational discussion is useful only when there is a significant base of shared assumptions." - Noam Chomsky
* "Testing shows the presence, not the absence of bugs" - Edsger W. Dijkstra
  embeds assumption of shifting, unpredictable environment
  in fact we can prove the absence of bugs *under some very specific conditions/assumptions*

* mocks and tests tell us little in isolation, more (lots?) in aggregate
  they embed the programmers understanding the system
  they provide some guarantees about behavior, however narrow
  but how do we harness that information

  programmers reading tests have a narrow focus

* mocks as assumptions
  when we test using mocks we state our assumptions about context in terms of those mocks

* tests as proofs under those assumptions
  tests prove a very particular property under a very particular set of assumptions defined by the mocks
  extremely narrow set of conditions

* assumptions can tell us interesting things about a system
  where should it be executing (posix, etc)
  what data should does it want from external resources (content)
  how should that data be delivered (format, async/sync, etc)
  what data should always/sometimes/never exist

* proofs
  best proofs are those that assume little and prove much
  e.g pure functions assume little other than some constraint on inputs

* proof theoretic view of "better proofs"

  T |- phi   T, phi |- psi
  ------------------------ (cut)
  T |- psi

  T |- psi
  -------------- (thinning)
  T, phi |- psi

  assuming nothing, T = {}, then phi must be an axiom/tautology or most importantly an *assumption*

* example

  e.g Rails "unit" tests

  |----+------------+-----------+-----|
  | id | first_name | last_name | ... |
  |----+------------+-----------+-----|
  | 1  | Jim        | Jones     |     |
  | 2  | Jackie     | Jormpjomp |     |
  | .  | .          | .         |     |
  | .  | .          | .         |     |
  | .  | .          | .         |     |
  |----+------------+-----------+-----|

  Test

  def test_full_name
    user = User.find(1)
    assert_equal(user.full_name, "Jim Jones")
  end

** assumptions
   - ...
   - database exists/accessible
   - user relation exists
   - user relation has at least one tuple
   - user relation has first_name
   - user relation has last_name
   - user relation's first row has first_name=Jim and last_name=Jones

** provable
   first row, the full_name method gets you "Jim Jones"

** not provable
   exists a row, full_name != "Jim Jones"

* extended example

  testing the positive and the negative of a method is a standard approach

  # positive
  def test_full_name_one
    user = User.find(1)
    assert_equal(user.full_name, "Jim Jones")
  end

  # negative
  def test_full_name_two
    user = User.find(2)
    assert(user.full_name != "Jim Jones")
  end

** assumptions
   - ...
   - database exists/accessible
   - user relation exists
   - user relation has at least one tuple
   - user relation has first_name
   - user relation has last_name
   - user relation's second row does not have first_name=Jim and last_name=Jones

** provable
   second row, the full_name method does not get you "Jim Jones"

** not provable
   exists a row, full_name = anything at all

* intersection of assumptions
** assumptions
  - ...
  - database exists/accessible
  - user relation exists
  - user relation has at least one tuple
  - user relation has first_name
  - user relation has last_name

** consistent context
   taking the union of shared assumptions provides a consistent context
   elides test specific extra context (second row, first row, etc)
   you could recover most of the schema from these assumptions

   (side note) a good system for helping people learn about code
   should make it easy to rebuild that system (e.g. recover schema)

* union of assumptions
  given all the assumptions made for all the tests,
  under the assumption they are consistent,
  what can we prove now?

** provable
   exists a row, full_name != "Jim Jones"
   exists a row, full_name = anything at all

* which proofs get grouped?
** module/class/etc
* how many assumptions should we include in the set?
** shouldn't get all the way down to one's and zeros
* how do you turn mocked code into readable assumptions
** in rails example can be derived from test database queries
** hard to make general, depends on mocking framework?
