* mocks as proof assumptions
 "Rational discussion is useful only when there is a significant base of shared assumptions." - Noam Chomsky

  "Testing shows the presence, not the absence of bugs" - Edsger W. Dijkstra
  - embeds assumption of shifting, unpredictable environment
  - in fact we can prove the absence of bugs *under some very specific conditions/assumptions*g
  - we approximate with "for all situations x, Q(x) ==> P" or "Q1(x), ... , Qn(x) |= P"

  Knowing about mocks means knowing the assumptions of tests and knowing
  the assumptions of tests means knowing the assumptions of the system about its context.

** mocks/tests: weak in isolation, strong in aggregate
   - they embed the programmers understanding the system
   - they provide some guarantees about behavior, however narrow
   - but how do we harness that information?
   - programmers reading tests have a narrow focus

** mocks as assumptions, tests as proofs
   - when we test using mocks we state our assumptions about context in terms of those mocks
   - tests prove a very particular property under a very particular set of assumptions defined by the mocks

** assumptions can tell us interesting things about a system
   - where should it be executing (posix, etc)
   - what data should does it want from external resources (content)
   - how should that data be delivered (format, async/sync, etc)
   - what data should always/sometimes/never exist

* example
  e.g Rails "unit" tests

  |----+------------+-----------+-----|
  | id | first_name | last_name | ... |
  |----+------------+-----------+-----|
  | 1  | Jim        | Jones     |     |
  | 2  | Jackie     | Jormpjomp |     |
  |----+------------+-----------+-----|

  Test

  #+begin_src ruby
  # positive
  def test_full_name
    user = User.find(1)
    assert_equal(user.full_name, "Jim Jones")
  end
  #+end_src

** assumptions
   - ...
   - database exists/accessible
   - user relation exists
   - user relation has at least one tuple
   - user relation has first_name
   - user relation has last_name
   - user relation's first row has first_name=Jim and last_name=Jones

   provable:
   - first row, the full_name method gets you "Jim Jones"

   not provable:
   - exists a row, full_name != "Jim Jones"

* extended example

  testing the positive and the negative of a method is a standard approach

  #+begin_src ruby
  # negative
  def test_full_name_two
    user = User.find(2)
    assert(user.full_name != "Jim Jones")
  end
  #+end_src

** assumptions
   - ...
   - database exists/accessible
   - user relation exists
   - user relation has at least one tuple
   - user relation has first_name
   - user relation has last_name
   - user relation's second row does not have first_name=Jim and last_name=Jones

   provable:
   - second row, the full_name method does not get you "Jim Jones"

   not provable:
   - gexists a row, full_name = anything at all

** intersection of assumptions
  - ...
  - database exists/accessible
  - user relation exists
  - user relation has at least one tuple
  - user relation has first_name
  - user relation has last_name

  taking the intersection of shared assumptions provides a consistent context
  and elides test specific extra context (second row, first row, etc).
  one could recover most of the schema from these assumptions

  (side note) a good system for helping people learn about code
  should make it easy to rebuild that system (e.g. recover schema)

** union of assumptions
   given all the assumptions made for all the tests,
   (if they are consistent)
   what can we prove now?

   provable:
   - exists a row, full_name != "Jim Jones"
   - exists a row, full_name = anything at all

* proofs
  - best proofs are those that assume little and prove much
  - e.g pure functions assume little other than some constraint on inputs

** proof theoretic view of minimal assumptions
   - minimum set of assumptions ==> most accurate view of context
   - tracking them as the intersection of thinnings?

   #+begin_src
   T |- psi
   -------------- (thinning)
   T, phi |- psi
   #+end_src

** example
   - rails sets up a lot of stuff for tests automatically but those things are well defined, `setup` methods also define assumptions.
   - search through the space of assumption sets to find minimal set where tests pass (i.e. proofs go through)

* questions
  - which proofs get grouped? module/class/etc
  - how many assumptions should we include in the set? shouldn't get all the way down to one's and zeros
  - how do you turn mocked code into readable assumptions? example can be derived from test database queries
  - hard to make general, depends on mocking framework?
